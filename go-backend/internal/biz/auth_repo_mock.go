// Code generated by mockery v2.53.4. DO NOT EDIT.

package biz

import (
	context "context"
	domain "go-backend/internal/domain"

	mock "github.com/stretchr/testify/mock"

	time "time"
)

// MockAuthRepo is an autogenerated mock type for the AuthRepo type
type MockAuthRepo struct {
	mock.Mock
}

type MockAuthRepo_Expecter struct {
	mock *mock.Mock
}

func (_m *MockAuthRepo) EXPECT() *MockAuthRepo_Expecter {
	return &MockAuthRepo_Expecter{mock: &_m.Mock}
}

// AddTokenToBlacklist provides a mock function with given fields: ctx, tokenID, expiresAt
func (_m *MockAuthRepo) AddTokenToBlacklist(ctx context.Context, tokenID string, expiresAt time.Time) error {
	ret := _m.Called(ctx, tokenID, expiresAt)

	if len(ret) == 0 {
		panic("no return value specified for AddTokenToBlacklist")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Time) error); ok {
		r0 = rf(ctx, tokenID, expiresAt)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockAuthRepo_AddTokenToBlacklist_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddTokenToBlacklist'
type MockAuthRepo_AddTokenToBlacklist_Call struct {
	*mock.Call
}

// AddTokenToBlacklist is a helper method to define mock.On call
//   - ctx context.Context
//   - tokenID string
//   - expiresAt time.Time
func (_e *MockAuthRepo_Expecter) AddTokenToBlacklist(ctx interface{}, tokenID interface{}, expiresAt interface{}) *MockAuthRepo_AddTokenToBlacklist_Call {
	return &MockAuthRepo_AddTokenToBlacklist_Call{Call: _e.mock.On("AddTokenToBlacklist", ctx, tokenID, expiresAt)}
}

func (_c *MockAuthRepo_AddTokenToBlacklist_Call) Run(run func(ctx context.Context, tokenID string, expiresAt time.Time)) *MockAuthRepo_AddTokenToBlacklist_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(time.Time))
	})
	return _c
}

func (_c *MockAuthRepo_AddTokenToBlacklist_Call) Return(_a0 error) *MockAuthRepo_AddTokenToBlacklist_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockAuthRepo_AddTokenToBlacklist_Call) RunAndReturn(run func(context.Context, string, time.Time) error) *MockAuthRepo_AddTokenToBlacklist_Call {
	_c.Call.Return(run)
	return _c
}

// CreateSession provides a mock function with given fields: ctx, session
func (_m *MockAuthRepo) CreateSession(ctx context.Context, session *domain.UserSession) error {
	ret := _m.Called(ctx, session)

	if len(ret) == 0 {
		panic("no return value specified for CreateSession")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *domain.UserSession) error); ok {
		r0 = rf(ctx, session)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockAuthRepo_CreateSession_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateSession'
type MockAuthRepo_CreateSession_Call struct {
	*mock.Call
}

// CreateSession is a helper method to define mock.On call
//   - ctx context.Context
//   - session *domain.UserSession
func (_e *MockAuthRepo_Expecter) CreateSession(ctx interface{}, session interface{}) *MockAuthRepo_CreateSession_Call {
	return &MockAuthRepo_CreateSession_Call{Call: _e.mock.On("CreateSession", ctx, session)}
}

func (_c *MockAuthRepo_CreateSession_Call) Run(run func(ctx context.Context, session *domain.UserSession)) *MockAuthRepo_CreateSession_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*domain.UserSession))
	})
	return _c
}

func (_c *MockAuthRepo_CreateSession_Call) Return(_a0 error) *MockAuthRepo_CreateSession_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockAuthRepo_CreateSession_Call) RunAndReturn(run func(context.Context, *domain.UserSession) error) *MockAuthRepo_CreateSession_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteSession provides a mock function with given fields: ctx, userID
func (_m *MockAuthRepo) DeleteSession(ctx context.Context, userID int64) error {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSession")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) error); ok {
		r0 = rf(ctx, userID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockAuthRepo_DeleteSession_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteSession'
type MockAuthRepo_DeleteSession_Call struct {
	*mock.Call
}

// DeleteSession is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int64
func (_e *MockAuthRepo_Expecter) DeleteSession(ctx interface{}, userID interface{}) *MockAuthRepo_DeleteSession_Call {
	return &MockAuthRepo_DeleteSession_Call{Call: _e.mock.On("DeleteSession", ctx, userID)}
}

func (_c *MockAuthRepo_DeleteSession_Call) Run(run func(ctx context.Context, userID int64)) *MockAuthRepo_DeleteSession_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64))
	})
	return _c
}

func (_c *MockAuthRepo_DeleteSession_Call) Return(_a0 error) *MockAuthRepo_DeleteSession_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockAuthRepo_DeleteSession_Call) RunAndReturn(run func(context.Context, int64) error) *MockAuthRepo_DeleteSession_Call {
	_c.Call.Return(run)
	return _c
}

// GetSession provides a mock function with given fields: ctx, userID
func (_m *MockAuthRepo) GetSession(ctx context.Context, userID int64) (*domain.UserSession, error) {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for GetSession")
	}

	var r0 *domain.UserSession
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) (*domain.UserSession, error)); ok {
		return rf(ctx, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64) *domain.UserSession); ok {
		r0 = rf(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.UserSession)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = rf(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAuthRepo_GetSession_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSession'
type MockAuthRepo_GetSession_Call struct {
	*mock.Call
}

// GetSession is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int64
func (_e *MockAuthRepo_Expecter) GetSession(ctx interface{}, userID interface{}) *MockAuthRepo_GetSession_Call {
	return &MockAuthRepo_GetSession_Call{Call: _e.mock.On("GetSession", ctx, userID)}
}

func (_c *MockAuthRepo_GetSession_Call) Run(run func(ctx context.Context, userID int64)) *MockAuthRepo_GetSession_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64))
	})
	return _c
}

func (_c *MockAuthRepo_GetSession_Call) Return(_a0 *domain.UserSession, _a1 error) *MockAuthRepo_GetSession_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAuthRepo_GetSession_Call) RunAndReturn(run func(context.Context, int64) (*domain.UserSession, error)) *MockAuthRepo_GetSession_Call {
	_c.Call.Return(run)
	return _c
}

// GetSessionByToken provides a mock function with given fields: ctx, refreshToken
func (_m *MockAuthRepo) GetSessionByToken(ctx context.Context, refreshToken string) (*domain.UserSession, error) {
	ret := _m.Called(ctx, refreshToken)

	if len(ret) == 0 {
		panic("no return value specified for GetSessionByToken")
	}

	var r0 *domain.UserSession
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*domain.UserSession, error)); ok {
		return rf(ctx, refreshToken)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *domain.UserSession); ok {
		r0 = rf(ctx, refreshToken)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.UserSession)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, refreshToken)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAuthRepo_GetSessionByToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSessionByToken'
type MockAuthRepo_GetSessionByToken_Call struct {
	*mock.Call
}

// GetSessionByToken is a helper method to define mock.On call
//   - ctx context.Context
//   - refreshToken string
func (_e *MockAuthRepo_Expecter) GetSessionByToken(ctx interface{}, refreshToken interface{}) *MockAuthRepo_GetSessionByToken_Call {
	return &MockAuthRepo_GetSessionByToken_Call{Call: _e.mock.On("GetSessionByToken", ctx, refreshToken)}
}

func (_c *MockAuthRepo_GetSessionByToken_Call) Run(run func(ctx context.Context, refreshToken string)) *MockAuthRepo_GetSessionByToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockAuthRepo_GetSessionByToken_Call) Return(_a0 *domain.UserSession, _a1 error) *MockAuthRepo_GetSessionByToken_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAuthRepo_GetSessionByToken_Call) RunAndReturn(run func(context.Context, string) (*domain.UserSession, error)) *MockAuthRepo_GetSessionByToken_Call {
	_c.Call.Return(run)
	return _c
}

// IsTokenBlacklisted provides a mock function with given fields: ctx, tokenID
func (_m *MockAuthRepo) IsTokenBlacklisted(ctx context.Context, tokenID string) (bool, error) {
	ret := _m.Called(ctx, tokenID)

	if len(ret) == 0 {
		panic("no return value specified for IsTokenBlacklisted")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (bool, error)); ok {
		return rf(ctx, tokenID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) bool); ok {
		r0 = rf(ctx, tokenID)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, tokenID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockAuthRepo_IsTokenBlacklisted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsTokenBlacklisted'
type MockAuthRepo_IsTokenBlacklisted_Call struct {
	*mock.Call
}

// IsTokenBlacklisted is a helper method to define mock.On call
//   - ctx context.Context
//   - tokenID string
func (_e *MockAuthRepo_Expecter) IsTokenBlacklisted(ctx interface{}, tokenID interface{}) *MockAuthRepo_IsTokenBlacklisted_Call {
	return &MockAuthRepo_IsTokenBlacklisted_Call{Call: _e.mock.On("IsTokenBlacklisted", ctx, tokenID)}
}

func (_c *MockAuthRepo_IsTokenBlacklisted_Call) Run(run func(ctx context.Context, tokenID string)) *MockAuthRepo_IsTokenBlacklisted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockAuthRepo_IsTokenBlacklisted_Call) Return(_a0 bool, _a1 error) *MockAuthRepo_IsTokenBlacklisted_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockAuthRepo_IsTokenBlacklisted_Call) RunAndReturn(run func(context.Context, string) (bool, error)) *MockAuthRepo_IsTokenBlacklisted_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateSession provides a mock function with given fields: ctx, userID, newRefreshToken, expiry
func (_m *MockAuthRepo) UpdateSession(ctx context.Context, userID int64, newRefreshToken string, expiry time.Duration) error {
	ret := _m.Called(ctx, userID, newRefreshToken, expiry)

	if len(ret) == 0 {
		panic("no return value specified for UpdateSession")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, string, time.Duration) error); ok {
		r0 = rf(ctx, userID, newRefreshToken, expiry)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockAuthRepo_UpdateSession_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateSession'
type MockAuthRepo_UpdateSession_Call struct {
	*mock.Call
}

// UpdateSession is a helper method to define mock.On call
//   - ctx context.Context
//   - userID int64
//   - newRefreshToken string
//   - expiry time.Duration
func (_e *MockAuthRepo_Expecter) UpdateSession(ctx interface{}, userID interface{}, newRefreshToken interface{}, expiry interface{}) *MockAuthRepo_UpdateSession_Call {
	return &MockAuthRepo_UpdateSession_Call{Call: _e.mock.On("UpdateSession", ctx, userID, newRefreshToken, expiry)}
}

func (_c *MockAuthRepo_UpdateSession_Call) Run(run func(ctx context.Context, userID int64, newRefreshToken string, expiry time.Duration)) *MockAuthRepo_UpdateSession_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64), args[2].(string), args[3].(time.Duration))
	})
	return _c
}

func (_c *MockAuthRepo_UpdateSession_Call) Return(_a0 error) *MockAuthRepo_UpdateSession_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockAuthRepo_UpdateSession_Call) RunAndReturn(run func(context.Context, int64, string, time.Duration) error) *MockAuthRepo_UpdateSession_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockAuthRepo creates a new instance of MockAuthRepo. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockAuthRepo(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockAuthRepo {
	mock := &MockAuthRepo{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
